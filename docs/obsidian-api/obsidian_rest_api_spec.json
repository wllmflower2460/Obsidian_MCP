{
  "components": {
    "schemas": {
      "Error": {
        "properties": {
          "errorCode": {
            "description": "A 5-digit error code uniquely identifying this particular type of error.\n",
            "example": 40149,
            "type": "number"
          },
          "message": {
            "description": "Message describing the error.",
            "example": "A brief description of the error.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "NoteJson": {
        "properties": {
          "content": {
            "type": "string"
          },
          "frontmatter": {
            "type": "object"
          },
          "path": {
            "type": "string"
          },
          "stat": {
            "properties": {
              "ctime": {
                "type": "number"
              },
              "mtime": {
                "type": "number"
              },
              "size": {
                "type": "number"
              }
            },
            "required": ["ctime", "mtime", "size"],
            "type": "object"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": ["tags", "frontmatter", "stat", "path", "content"],
        "type": "object"
      }
    },
    "securitySchemes": {
      "apiKeyAuth": {
        "description": "Find your API Key in your Obsidian settings\nin the \"Local REST API\" section under \"Plugins\".\n",
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "info": {
    "description": "You can use this interface for trying out your Local REST API in Obsidian.\n\nBefore trying the below tools, you will want to make sure you press the \"Authorize\" button below and provide the API Key you are shown when you open the \"Local REST API\" section of your Obsidian settings.  All requests to the API require a valid API Key; so you won't get very far without doing that.\n\nWhen using this tool you may see browser security warnings due to your browser not trusting the self-signed certificate the plugin will generate on its first run.  If you do, you can make those errors disappear by adding the certificate as a \"Trusted Certificate\" in your browser or operating system's settings.\n",
    "title": "Local REST API for Obsidian",
    "version": "1.0"
  },
  "openapi": "3.0.2",
  "paths": {
    "/": {
      "get": {
        "description": "Returns basic details about the server as well as your authentication status.\n\nThis is the only API request that does *not* require authentication.\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "authenticated": {
                      "description": "Is your current request authenticated?",
                      "type": "boolean"
                    },
                    "ok": {
                      "description": "'OK'",
                      "type": "string"
                    },
                    "service": {
                      "description": "'Obsidian Local REST API'",
                      "type": "string"
                    },
                    "versions": {
                      "properties": {
                        "obsidian": {
                          "description": "Obsidian plugin API version",
                          "type": "string"
                        },
                        "self": {
                          "description": "Plugin version.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Success"
          }
        },
        "summary": "Returns basic details about the server.\n",
        "tags": ["Status"]
      }
    },
    "/active/": {
      "delete": {
        "parameters": [],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "File does not exist."
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Deletes the currently-active file in Obsidian.\n",
        "tags": ["Active File"]
      },
      "get": {
        "description": "Returns the content of the currently active file in Obsidian.\n\nIf you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See \"responses\" below for details.\n",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/vnd.olrapi.note+json": {
                "schema": {
                  "$ref": "#/components/schemas/NoteJson"
                }
              },
              "text/markdown": {
                "schema": {
                  "example": "# This is my document\n\nsomething else here\n",
                  "type": "string"
                }
              }
            },
            "description": "Success"
          },
          "404": {
            "description": "File does not exist"
          }
        },
        "summary": "Return the content of the active file open in Obsidian.\n",
        "tags": ["Active File"]
      },
      "patch": {
        "description": "Inserts content into the currently-open note relative to a heading within that note.\n\nAllows you to modify the content relative to a heading, block reference, or frontmatter field in your document.\n\nNote that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.\n\n# Examples\n\nAll of the below examples assume you have a document that looks like\nthis:\n\n```markdown\n---\nalpha: 1\nbeta: test\ndelta:\nzeta: 1\nyotta: 1\ngamma:\n- one\n- two\n---\n\n# Heading 1\n\nThis is the content for heading one\n\nAlso references some [[#^484ef2]]\n\n## Subheading 1:1\nContent for Subheading 1:1\n\n### Subsubheading 1:1:1\n\n### Subsubheading 1:1:2\n\nTesting how block references work for a table.[[#^2c7cfa]]\nSome content for Subsubheading 1:1:2\n\nMore random text.\n\n^2d9b4a\n\n## Subheading 1:2\n\nContent for Subheading 1:2.\n\nsome content with a block reference ^484ef2\n\n## Subheading 1:3\n| City         | Population |\n| ------------ | ---------- |\n| Seattle, WA  | 8          |\n| Portland, OR | 4          |\n\n^2c7cfa\n```\n\n## Append Content Below a Heading\n\nIf you wanted to append the content \"Hello\" below \"Subheading 1:1:1\" under \"Heading 1\",\nyou could send a request with the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `heading`\n- `Target`: `Heading 1::Subheading 1:1:1`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Append Content to a Block Reference\n\nIf you wanted to append the content \"Hello\" below the block referenced by\n\"2d9b4a\" above (\"More random text.\"), you could send the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `block`\n- `Target`: `2d9b4a`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Add a Row to a Table Referenced by a Block Reference\n\nIf you wanted to add a new city (\"Chicago, IL\") and population (\"16\") pair to the table above\nreferenced by the block reference `2c7cfa`, you could send the following\nheaders:\n\n- `Operation`: `append`\n- `TargetType`: `block`\n- `Target`: `2c7cfa`\n- `Content-Type`: `application/json`\n- with the request body: `[[\"Chicago, IL\", \"16\"]]`\n\nThe use of a `Content-Type` of `application/json` allows the API\nto infer that member of your array represents rows and columns of your\nto append to the referenced table.  You can of course just use a\n`Content-Type` of `text/markdown`, but in such a case you'll have to\nformat your table row manually instead of letting the library figure\nit out for you.\n\nYou also have the option of using `prepend` (in which case, your new\nrow would be the first -- right below the table heading) or `replace` (in which\ncase all rows except the table heading would be replaced by the new row(s)\nyou supplied).\n\n## Setting a Frontmatter Field\n\nIf you wanted to set the frontmatter field `alpha` to `2`, you could\nsend the following headers:\n\n- `Operation`: `replace`\n- `TargetType`: `frontmatter`\n- `Target`: `beep`\n- with the request body `2`\n\nIf you're setting a frontmatter field that might not already exist\nyou may want to use the `Create-Target-If-Missing` header so the\nnew frontmatter field is created and set to your specified value\nif it doesn't already exist.\n\nYou may find using a `Content-Type` of `application/json` to be\nparticularly useful in the case of frontmatter since frontmatter\nfields' values are JSON data, and the API can be smarter about\ninterpreting yoru `prepend` or `append` requests if you specify\nyour data as JSON (particularly when appending, for example,\nlist items).\n",
        "parameters": [
          {
            "description": "Patch operation to perform",
            "in": "header",
            "name": "Operation",
            "required": true,
            "schema": {
              "enum": ["append", "prepend", "replace"],
              "type": "string"
            }
          },
          {
            "description": "Type of target to patch",
            "in": "header",
            "name": "Target-Type",
            "required": true,
            "schema": {
              "enum": ["heading", "block", "frontmatter"],
              "type": "string"
            }
          },
          {
            "description": "Delimiter to use for nested targets (i.e. Headings)",
            "in": "header",
            "name": "Target-Delimiter",
            "required": false,
            "schema": {
              "default": "::",
              "type": "string"
            }
          },
          {
            "description": "Target to patch; this value can be URL-Encoded and *must*\nbe URL-Encoded if it includes non-ASCII characters.\n",
            "in": "header",
            "name": "Target",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Trim whitespace from Target before applying patch?",
            "in": "header",
            "name": "Trim-Target-Whitespace",
            "required": false,
            "schema": {
              "default": "false",
              "enum": ["true", "false"],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "example": "['one', 'two']",
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to insert.",
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request; see response message for details."
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Does not exist"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Insert content into the currently open note in Obsidian relative to a heading within that document.\n",
        "tags": ["Active File"]
      },
      "post": {
        "description": "Appends content to the end of the currently-open note.\n\nIf you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.\n",
        "parameters": [],
        "requestBody": {
          "content": {
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to append.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Append content to the active file open in Obsidian.\n",
        "tags": ["Active File"]
      },
      "put": {
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content of the file you would like to upload.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.\n"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Update the content of the active file open in Obsidian.\n",
        "tags": ["Active File"]
      }
    },
    "/commands/": {
      "get": {
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "commands": [
                    {
                      "id": "global-search:open",
                      "name": "Search: Search in all files"
                    },
                    {
                      "id": "graph:open",
                      "name": "Graph view: Open graph view"
                    }
                  ]
                },
                "schema": {
                  "properties": {
                    "commands": {
                      "items": {
                        "properties": {
                          "id": {
                            "type": "string"
                          },
                          "name": {
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "A list of available commands."
          }
        },
        "summary": "Get a list of available commands.\n",
        "tags": ["Commands"]
      }
    },
    "/commands/{commandId}/": {
      "post": {
        "parameters": [
          {
            "description": "The id of the command to execute",
            "in": "path",
            "name": "commandId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "The command you specified does not exist."
          }
        },
        "summary": "Execute a command.\n",
        "tags": ["Commands"]
      }
    },
    "/open/{filename}": {
      "post": {
        "description": "Opens the specified document in Obsidian.\n\nNote: Obsidian will create a new document at the path you have\nspecified if such a document did not already exist.\n",
        "parameters": [
          {
            "description": "Path to the file to return (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          },
          {
            "description": "Open this as a new leaf?",
            "in": "query",
            "name": "newLeaf",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success"
          }
        },
        "summary": "Open the specified document in Obsidian\n",
        "tags": ["Open"]
      }
    },
    "/periodic/{period}/": {
      "delete": {
        "description": "Deletes the periodic note for the specified period.\n",
        "parameters": [
          {
            "description": "The name of the period for which you would like to grab the current note.",
            "in": "path",
            "name": "period",
            "required": true,
            "schema": {
              "default": "daily",
              "enum": ["daily", "weekly", "monthly", "quarterly", "yearly"],
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "File does not exist."
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Delete a periodic note.\n",
        "tags": ["Periodic Notes"]
      },
      "get": {
        "parameters": [
          {
            "description": "The name of the period for which you would like to grab the current note.",
            "in": "path",
            "name": "period",
            "required": true,
            "schema": {
              "default": "daily",
              "enum": ["daily", "weekly", "monthly", "quarterly", "yearly"],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.olrapi.note+json": {
                "schema": {
                  "$ref": "#/components/schemas/NoteJson"
                }
              },
              "text/markdown": {
                "schema": {
                  "example": "# This is my document\n\nsomething else here\n",
                  "type": "string"
                }
              }
            },
            "description": "Success"
          },
          "404": {
            "description": "File does not exist"
          }
        },
        "summary": "Get current periodic note for the specified period.\n",
        "tags": ["Periodic Notes"]
      },
      "patch": {
        "description": "Inserts content into an existing note relative to a heading within your note.\n\nAllows you to modify the content relative to a heading, block reference, or frontmatter field in your document.\n\nNote that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.\n\n# Examples\n\nAll of the below examples assume you have a document that looks like\nthis:\n\n```markdown\n---\nalpha: 1\nbeta: test\ndelta:\nzeta: 1\nyotta: 1\ngamma:\n- one\n- two\n---\n\n# Heading 1\n\nThis is the content for heading one\n\nAlso references some [[#^484ef2]]\n\n## Subheading 1:1\nContent for Subheading 1:1\n\n### Subsubheading 1:1:1\n\n### Subsubheading 1:1:2\n\nTesting how block references work for a table.[[#^2c7cfa]]\nSome content for Subsubheading 1:1:2\n\nMore random text.\n\n^2d9b4a\n\n## Subheading 1:2\n\nContent for Subheading 1:2.\n\nsome content with a block reference ^484ef2\n\n## Subheading 1:3\n| City         | Population |\n| ------------ | ---------- |\n| Seattle, WA  | 8          |\n| Portland, OR | 4          |\n\n^2c7cfa\n```\n\n## Append Content Below a Heading\n\nIf you wanted to append the content \"Hello\" below \"Subheading 1:1:1\" under \"Heading 1\",\nyou could send a request with the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `heading`\n- `Target`: `Heading 1::Subheading 1:1:1`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Append Content to a Block Reference\n\nIf you wanted to append the content \"Hello\" below the block referenced by\n\"2d9b4a\" above (\"More random text.\"), you could send the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `block`\n- `Target`: `2d9b4a`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Add a Row to a Table Referenced by a Block Reference\n\nIf you wanted to add a new city (\"Chicago, IL\") and population (\"16\") pair to the table above\nreferenced by the block reference `2c7cfa`, you could send the following\nheaders:\n\n- `Operation`: `append`\n- `TargetType`: `block`\n- `Target`: `2c7cfa`\n- `Content-Type`: `application/json`\n- with the request body: `[[\"Chicago, IL\", \"16\"]]`\n\nThe use of a `Content-Type` of `application/json` allows the API\nto infer that member of your array represents rows and columns of your\nto append to the referenced table.  You can of course just use a\n`Content-Type` of `text/markdown`, but in such a case you'll have to\nformat your table row manually instead of letting the library figure\nit out for you.\n\nYou also have the option of using `prepend` (in which case, your new\nrow would be the first -- right below the table heading) or `replace` (in which\ncase all rows except the table heading would be replaced by the new row(s)\nyou supplied).\n\n## Setting a Frontmatter Field\n\nIf you wanted to set the frontmatter field `alpha` to `2`, you could\nsend the following headers:\n\n- `Operation`: `replace`\n- `TargetType`: `frontmatter`\n- `Target`: `beep`\n- with the request body `2`\n\nIf you're setting a frontmatter field that might not already exist\nyou may want to use the `Create-Target-If-Missing` header so the\nnew frontmatter field is created and set to your specified value\nif it doesn't already exist.\n\nYou may find using a `Content-Type` of `application/json` to be\nparticularly useful in the case of frontmatter since frontmatter\nfields' values are JSON data, and the API can be smarter about\ninterpreting yoru `prepend` or `append` requests if you specify\nyour data as JSON (particularly when appending, for example,\nlist items).\n",
        "parameters": [
          {
            "description": "Patch operation to perform",
            "in": "header",
            "name": "Operation",
            "required": true,
            "schema": {
              "enum": ["append", "prepend", "replace"],
              "type": "string"
            }
          },
          {
            "description": "Type of target to patch",
            "in": "header",
            "name": "Target-Type",
            "required": true,
            "schema": {
              "enum": ["heading", "block", "frontmatter"],
              "type": "string"
            }
          },
          {
            "description": "Delimiter to use for nested targets (i.e. Headings)",
            "in": "header",
            "name": "Target-Delimiter",
            "required": false,
            "schema": {
              "default": "::",
              "type": "string"
            }
          },
          {
            "description": "Target to patch; this value can be URL-Encoded and *must*\nbe URL-Encoded if it includes non-ASCII characters.\n",
            "in": "header",
            "name": "Target",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Trim whitespace from Target before applying patch?",
            "in": "header",
            "name": "Trim-Target-Whitespace",
            "required": false,
            "schema": {
              "default": "false",
              "enum": ["true", "false"],
              "type": "string"
            }
          },
          {
            "description": "The name of the period for which you would like to grab the current note.",
            "in": "path",
            "name": "period",
            "required": true,
            "schema": {
              "default": "daily",
              "enum": ["daily", "weekly", "monthly", "quarterly", "yearly"],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "example": "['one', 'two']",
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to insert.",
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request; see response message for details."
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Does not exist"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Insert content into a periodic note relative to a heading within that document.\n",
        "tags": ["Periodic Notes"]
      },
      "post": {
        "description": "Appends content to the periodic note for the specified period.  This will create the relevant periodic note if necessary.\n",
        "parameters": [
          {
            "description": "The name of the period for which you would like to grab the current note.",
            "in": "path",
            "name": "period",
            "required": true,
            "schema": {
              "default": "daily",
              "enum": ["daily", "weekly", "monthly", "quarterly", "yearly"],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to append.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Append content to a periodic note.\n",
        "tags": ["Periodic Notes"]
      },
      "put": {
        "parameters": [
          {
            "description": "The name of the period for which you would like to grab the current note.",
            "in": "path",
            "name": "period",
            "required": true,
            "schema": {
              "default": "daily",
              "enum": ["daily", "weekly", "monthly", "quarterly", "yearly"],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content of the file you would like to upload.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.\n"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Update the content of a periodic note.\n",
        "tags": ["Periodic Notes"]
      }
    },
    "/search/": {
      "post": {
        "description": "Evaluates a provided query against each file in your vault.\n\nThis endpoint supports multiple query formats.  Your query should be specified in your request's body, and will be interpreted according to the `Content-type` header you specify from the below options.Additional query formats may be added in the future.\n\n# Dataview DQL (`application/vnd.olrapi.dataview.dql+txt`)\n\nAccepts a `TABLE`-type Dataview query as a text string.  See [Dataview](https://blacksmithgu.github.io/obsidian-dataview/query/queries/)'s query documentation for information on how to construct a query.\n\n# JsonLogic (`application/vnd.olrapi.jsonlogic+json`)\n\nAccepts a JsonLogic query specified as JSON.  See [JsonLogic](https://jsonlogic.com/operations.html)'s documentation for information about the base set of operators available, but in addition to those operators the following operators are available:\n\n- `glob: [PATTERN, VALUE]`: Returns `true` if a string matches a glob pattern.  E.g.: `{\"glob\": [\"*.foo\", \"bar.foo\"]}` is `true` and `{\"glob\": [\"*.bar\", \"bar.foo\"]}` is `false`.\n- `regexp: [PATTERN, VALUE]`: Returns `true` if a string matches a regular expression.  E.g.: `{\"regexp\": [\".*\\.foo\", \"bar.foo\"]` is `true` and `{\"regexp\": [\".*\\.bar\", \"bar.foo\"]}` is `false`.\n\nReturns only non-falsy results.  \"Non-falsy\" here treats the following values as \"falsy\":\n\n- `false`\n- `null` or `undefined`\n- `0`\n- `[]`\n- `{}`\n\nFiles are represented as an object having the schema described\nin the Schema named 'NoteJson' at the bottom of this page.\nUnderstanding the shape of a JSON object from a schema can be\ntricky; so you may find it helpful to examine the generated metadata\nfor individual files in your vault to understand exactly what values\nare returned.  To see that, access the `GET` `/vault/{filePath}`\nroute setting the header:\n`Accept: application/vnd.olrapi.note+json`.  See examples below\nfor working examples of queries performing common search operations.\n",
        "requestBody": {
          "content": {
            "application/vnd.olrapi.dataview.dql+txt": {
              "examples": {
                "find_fields_by_tag": {
                  "summary": "List data from files having the #game tag.",
                  "value": "TABLE\n  time-played AS \"Time Played\",\n  length AS \"Length\",\n  rating AS \"Rating\"\nFROM #game\nSORT rating DESC\n"
                }
              },
              "schema": {
                "externalDocs": {
                  "url": "https://blacksmithgu.github.io/obsidian-dataview/query/queries/"
                },
                "type": "object"
              }
            },
            "application/vnd.olrapi.jsonlogic+json": {
              "examples": {
                "find_by_frontmatter_url_glob": {
                  "summary": "Find notes having URL or a matching URL glob frontmatter field.",
                  "value": "{\n  \"or\": [\n    {\"===\": [{\"var\": \"frontmatter.url\"}, \"https://myurl.com/some/path/\"]},\n    {\"glob\": [{\"var\": \"frontmatter.url-glob\"}, \"https://myurl.com/some/path/\"]}\n  ]\n}\n"
                },
                "find_by_frontmatter_value": {
                  "summary": "Find notes having a certain frontmatter field value.",
                  "value": "{\n  \"==\": [\n    {\"var\": \"frontmatter.myField\"},\n    \"myValue\"\n  ]\n}\n"
                },
                "find_by_tag": {
                  "summary": "Find notes having a certain tag",
                  "value": "{\n  \"in\": [\n    \"myTag\",\n    {\"var\": \"tags\"}\n  ]\n}\n"
                }
              },
              "schema": {
                "externalDocs": {
                  "url": "https://jsonlogic.com/operations.html"
                },
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "properties": {
                      "filename": {
                        "description": "Path to the matching file",
                        "type": "string"
                      },
                      "result": {
                        "oneOf": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "array"
                          },
                          {
                            "type": "object"
                          },
                          {
                            "type": "boolean"
                          }
                        ]
                      }
                    },
                    "required": ["filename", "result"],
                    "type": "object"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad request.  Make sure you have specified an acceptable\nContent-Type for your search query.\n"
          }
        },
        "summary": "Search for documents matching a specified search query\n",
        "tags": ["Search"]
      }
    },
    "/search/simple/": {
      "post": {
        "parameters": [
          {
            "description": "Your search query",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "How much context to return around the matching string",
            "in": "query",
            "name": "contextLength",
            "required": false,
            "schema": {
              "default": 100,
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "properties": {
                      "filename": {
                        "description": "Path to the matching file",
                        "type": "string"
                      },
                      "matches": {
                        "items": {
                          "properties": {
                            "context": {
                              "type": "string"
                            },
                            "match": {
                              "properties": {
                                "end": {
                                  "type": "number"
                                },
                                "start": {
                                  "type": "number"
                                }
                              },
                              "required": ["start", "end"],
                              "type": "object"
                            }
                          },
                          "required": ["match", "context"],
                          "type": "object"
                        },
                        "type": "array"
                      },
                      "score": {
                        "type": "number"
                      }
                    },
                    "type": "object"
                  },
                  "type": "array"
                }
              }
            },
            "description": "Success"
          }
        },
        "summary": "Search for documents matching a specified text query\n",
        "tags": ["Search"]
      }
    },
    "/vault/": {
      "get": {
        "description": "Lists files in the root directory of your vault.\n\nNote: that this is exactly the same API endpoint as the below \"List files that exist in the specified directory.\" and exists here only due to a quirk of this particular interactive tool.\n",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "files": ["mydocument.md", "somedirectory/"]
                },
                "schema": {
                  "properties": {
                    "files": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Directory does not exist"
          }
        },
        "summary": "List files that exist in the root of your vault.\n",
        "tags": ["Vault Directories"]
      }
    },
    "/vault/{filename}": {
      "delete": {
        "parameters": [
          {
            "description": "Path to the relevant file (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "File does not exist."
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Delete a particular file in your vault.\n",
        "tags": ["Vault Files"]
      },
      "get": {
        "description": "Returns the content of the file at the specified path in your vault should the file exist.\n\nIf you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See \"responses\" below for details.\n",
        "parameters": [
          {
            "description": "Path to the relevant file (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/vnd.olrapi.note+json": {
                "schema": {
                  "$ref": "#/components/schemas/NoteJson"
                }
              },
              "text/markdown": {
                "schema": {
                  "example": "# This is my document\n\nsomething else here\n",
                  "type": "string"
                }
              }
            },
            "description": "Success"
          },
          "404": {
            "description": "File does not exist"
          }
        },
        "summary": "Return the content of a single file in your vault.\n",
        "tags": ["Vault Files"]
      },
      "patch": {
        "description": "Inserts content into an existing note relative to a heading within your note.\n\nAllows you to modify the content relative to a heading, block reference, or frontmatter field in your document.\n\nNote that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.\n\n# Examples\n\nAll of the below examples assume you have a document that looks like\nthis:\n\n```markdown\n---\nalpha: 1\nbeta: test\ndelta:\nzeta: 1\nyotta: 1\ngamma:\n- one\n- two\n---\n\n# Heading 1\n\nThis is the content for heading one\n\nAlso references some [[#^484ef2]]\n\n## Subheading 1:1\nContent for Subheading 1:1\n\n### Subsubheading 1:1:1\n\n### Subsubheading 1:1:2\n\nTesting how block references work for a table.[[#^2c7cfa]]\nSome content for Subsubheading 1:1:2\n\nMore random text.\n\n^2d9b4a\n\n## Subheading 1:2\n\nContent for Subheading 1:2.\n\nsome content with a block reference ^484ef2\n\n## Subheading 1:3\n| City         | Population |\n| ------------ | ---------- |\n| Seattle, WA  | 8          |\n| Portland, OR | 4          |\n\n^2c7cfa\n```\n\n## Append Content Below a Heading\n\nIf you wanted to append the content \"Hello\" below \"Subheading 1:1:1\" under \"Heading 1\",\nyou could send a request with the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `heading`\n- `Target`: `Heading 1::Subheading 1:1:1`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Append Content to a Block Reference\n\nIf you wanted to append the content \"Hello\" below the block referenced by\n\"2d9b4a\" above (\"More random text.\"), you could send the following headers:\n\n- `Operation`: `append`\n- `Target-Type`: `block`\n- `Target`: `2d9b4a`\n- with the request body: `Hello`\n\nThe above would work just fine for `prepend` or `replace`, too, of course,\nbut with different results.\n\n## Add a Row to a Table Referenced by a Block Reference\n\nIf you wanted to add a new city (\"Chicago, IL\") and population (\"16\") pair to the table above\nreferenced by the block reference `2c7cfa`, you could send the following\nheaders:\n\n- `Operation`: `append`\n- `TargetType`: `block`\n- `Target`: `2c7cfa`\n- `Content-Type`: `application/json`\n- with the request body: `[[\"Chicago, IL\", \"16\"]]`\n\nThe use of a `Content-Type` of `application/json` allows the API\nto infer that member of your array represents rows and columns of your\nto append to the referenced table.  You can of course just use a\n`Content-Type` of `text/markdown`, but in such a case you'll have to\nformat your table row manually instead of letting the library figure\nit out for you.\n\nYou also have the option of using `prepend` (in which case, your new\nrow would be the first -- right below the table heading) or `replace` (in which\ncase all rows except the table heading would be replaced by the new row(s)\nyou supplied).\n\n## Setting a Frontmatter Field\n\nIf you wanted to set the frontmatter field `alpha` to `2`, you could\nsend the following headers:\n\n- `Operation`: `replace`\n- `TargetType`: `frontmatter`\n- `Target`: `beep`\n- with the request body `2`\n\nIf you're setting a frontmatter field that might not already exist\nyou may want to use the `Create-Target-If-Missing` header so the\nnew frontmatter field is created and set to your specified value\nif it doesn't already exist.\n\nYou may find using a `Content-Type` of `application/json` to be\nparticularly useful in the case of frontmatter since frontmatter\nfields' values are JSON data, and the API can be smarter about\ninterpreting yoru `prepend` or `append` requests if you specify\nyour data as JSON (particularly when appending, for example,\nlist items).\n",
        "parameters": [
          {
            "description": "Patch operation to perform",
            "in": "header",
            "name": "Operation",
            "required": true,
            "schema": {
              "enum": ["append", "prepend", "replace"],
              "type": "string"
            }
          },
          {
            "description": "Type of target to patch",
            "in": "header",
            "name": "Target-Type",
            "required": true,
            "schema": {
              "enum": ["heading", "block", "frontmatter"],
              "type": "string"
            }
          },
          {
            "description": "Delimiter to use for nested targets (i.e. Headings)",
            "in": "header",
            "name": "Target-Delimiter",
            "required": false,
            "schema": {
              "default": "::",
              "type": "string"
            }
          },
          {
            "description": "Target to patch; this value can be URL-Encoded and *must*\nbe URL-Encoded if it includes non-ASCII characters.\n",
            "in": "header",
            "name": "Target",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Trim whitespace from Target before applying patch?",
            "in": "header",
            "name": "Trim-Target-Whitespace",
            "required": false,
            "schema": {
              "default": "false",
              "enum": ["true", "false"],
              "type": "string"
            }
          },
          {
            "description": "Path to the relevant file (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "example": "['one', 'two']",
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to insert.",
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request; see response message for details."
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Does not exist"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Insert content into an existing note relative to a heading within that document.\n",
        "tags": ["Vault Files"]
      },
      "post": {
        "description": "Appends content to the end of an existing note. If the specified file does not yet exist, it will be created as an empty file.\n\nIf you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.\n",
        "parameters": [
          {
            "description": "Path to the relevant file (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content you would like to append.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Bad Request"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Append content to a new or existing file.\n",
        "tags": ["Vault Files"]
      },
      "put": {
        "description": "Creates a new file in your vault or updates the content of an existing one if the specified file already exists.\n",
        "parameters": [
          {
            "description": "Path to the relevant file (relative to your vault root).\n",
            "in": "path",
            "name": "filename",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "string"
              }
            },
            "text/markdown": {
              "schema": {
                "example": "# This is my document\n\nsomething else here\n",
                "type": "string"
              }
            }
          },
          "description": "Content of the file you would like to upload.",
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.\n"
          },
          "405": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Your path references a directory instead of a file; this request method is valid only for updating files.\n"
          }
        },
        "summary": "Create a new file in your vault or update the content of an existing one.\n",
        "tags": ["Vault Files"]
      }
    },
    "/vault/{pathToDirectory}/": {
      "get": {
        "parameters": [
          {
            "description": "Path to list files from (relative to your vault root).  Note that empty directories will not be returned.\n\nNote: this particular interactive tool requires that you provide an argument for this field, but the API itself will allow you to list the root folder of your vault. If you would like to try listing content in the root of your vault using this interactive tool, use the above \"List files that exist in the root of your vault\" form above.\n",
            "in": "path",
            "name": "pathToDirectory",
            "required": true,
            "schema": {
              "format": "path",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "example": {
                  "files": ["mydocument.md", "somedirectory/"]
                },
                "schema": {
                  "properties": {
                    "files": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Success"
          },
          "404": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "description": "Directory does not exist"
          }
        },
        "summary": "List files that exist in the specified directory.\n",
        "tags": ["Vault Directories"]
      }
    }
  },
  "security": [
    {
      "apiKeyAuth": []
    }
  ],
  "servers": [
    {
      "description": "HTTPS (Secure Mode)",
      "url": "https://{host}:{port}",
      "variables": {
        "host": {
          "default": "127.0.0.1",
          "description": "Binding host"
        },
        "port": {
          "default": "27124",
          "description": "HTTPS port"
        }
      }
    },
    {
      "description": "HTTP (Insecure Mode)",
      "url": "http://{host}:{port}",
      "variables": {
        "host": {
          "default": "127.0.0.1",
          "description": "Binding host"
        },
        "port": {
          "default": "27123",
          "description": "HTTP port"
        }
      }
    }
  ]
}
